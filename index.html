<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOUCH event</title>
    <canvas id="canvas" width="1080" height="690"  ></canvas>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;


    // 四角図形を描く
    let leftn;
    let kosu;
    let rectl = 160;
    let rectt = 270;
    let rectw = 50;
    // menu
    let r1 = 50;
    let mode;
    mode = 0;
    let yubikotae; // 指答え
    let yubicnt; // 指カウント
    let seikaisu_itirans = [ // 面,正解数,設定数,タイム
        [1,0,5,0],
        [2,0,5,0],
        [3,0,5,0],
        [4,0,5,0],
        [5,0,5,0],
        [6,0,5,0],
        [7,0,5,0],
        [8,0,5,0],
    ];
    // 解答欄
    let kleft = 550;
    let ktop = 50;
    let kwidth = 400;
    let kheight = 550;
    //let isSeikai;
    //isSeikai = false;
    let seikai_cnt;
    let touchPoints = [];
    let sikakus = [];
    let sikakus_ima = [];
    let sikakus_end = [];
    let stime;
    let oodokei;
    let stoptimes = [];
    let keikatime_h;
    let pushtime;
    // sound
    correct = new Audio('correct.mp3');
    correct.preload = 'auto';
    //correct.load();
    wrong = new Audio('wrong.mp3');
    wrong.preload = 'auto';

    // ----- start page -----
    function sentaku_aka(mode){ 
    // canvas全体をクリア
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 外枠の色と太さを設定
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    // 矩形を描画 (x, y, 幅, 高さ)
    ctx.strokeRect(0, 0, canvas.width-30, canvas.height-30);    
    // フォントの読み込み完了後に実行
    document.fonts.ready.then(() => {
        ctx.font = "8px 'sans-serif'";
        ctx.fillText("ver01",10,15);
        ctx.font = "20px 'sans-serif'";
        ctx.fillText("<メニュー>", 70, 60);
        ctx.fillText("正解数", 600, 60);
        ctx.fillText("タイム", 700, 60);
    });
        if (mode == 0) {fillStyle = 'black';}
        ctx.font = "sans-serif 20px";
        text_menus = ['１　５のをつくる',
        '２　合わせて５になる足し算',
        '３　５以上になる足し算',
        '４　１０の分解',
        '５　繰り上がりなしの足し算１（足す数が５まで）',
        '６　１０いくつとの和',
        '７　２桁＋２桁（くりあがりなし）',
        '８　２桁＋２桁（くりあがりあり）',
        ];
        document.fonts.ready.then(() => {
        for (i=0;i<8;i++){
            if (mode == i+1) {
                fillStyle = 'red';
            } else {
                fillStyle = 'black';
            }
            ctx.fillText(text_menus[i],100,100+r1*i);
            ctx.fillText(seikaisu_itirans[i][1],600,100+r1*i);
            ctx.fillText("/",620,100+r1*i);
            ctx.fillText(seikaisu_itirans[i][2],640,100+r1*i);
            ctx.fillText(seikaisu_itirans[i][3],750,100+r1*i);
        }
        });

        // 大時計
        oodokei = new Date().getTime;
    }
    
    // ----- mode1 -----
    function mode1() {
        // canvas全体をクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 矩形を描画 (x, y, 幅, 高さ)
        ctx.strokeRect(0, 0, canvas.width-30, canvas.height-30);
        // タイトル
        ctx.font = "36px";
        ctx.fillText("５をつくる",400,100);
        // 乱数の決定
        leftn = Math.floor(Math.random()*4)+1;
        console.log("leftn=",leftn);
        yubikotae = 5-leftn; 

        ctx.font = "96px";
        ctx.fillText("5  =",100,300);
        ctx.fillText("+",450,300);
        for (i=0;i<leftn;i++){
            // 四角塗りつぶし
            ctx.fillStyle = 'skyblue';
            ctx.fillRect(rectl+rectw*i, rectt, rectw, rectw);
            // 四角縁取り
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(rectl+rectw*i, rectt, rectw, rectw);
        }
        //ctx.font = "20px";
        //ctx.fillStyle = 'black';

        // 解答欄をクリア
        kaitouran_clear();
    }
    // 解答欄クリア
    function kaitouran_clear() {
        // 解答欄
        // 全体をクリア
        ctx.clearRect(kleft-20, ktop-20, kwidth+40, kheight+40);
        // 四角塗りつぶし
        // set transparency value
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = '#9bea33';
        ctx.fillRect(kleft, ktop, kwidth, kheight);

        // 四角縁取り
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(kleft, ktop, kwidth, kheight);
        ctx.globalAlpha = 1;
    }

    function redraw_sikaku_plus(sikakus) {
        ctx.clearRect(50,200,440,400);
        ctx.font = "96px";
        ctx.fillStyle = 'black';
        ctx.fillText("5  =",100,300);
        ctx.fillText("+",450,300);
        kosu = leftn + sikakus.length;
        //ctx.clearRect(40,20,100,80);//
        //ctx.fillText("kosu:",40,60)//
        //ctx.fillText(kosu,90,60);//
        for (i=0;i<kosu;i++){
            // 四角塗りつぶし
            if (i<5) { //０始まりなので５
                ctx.fillStyle = 'skyblue';
            } 
            if (5<=i && i<10) {
                ctx.fillStyle = 'pink';
            } 
            xi = i % 5;
            yi = Math.floor(i/5);
            // 四角形
            ctx.fillRect(rectl+rectw*xi, rectt+(rectw+20)*yi, rectw, rectw);
            // 四角縁取り
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(rectl+rectw*xi, rectt+(rectw+20)*yi, rectw, rectw);
        }
        setTimeout(() => {
            //ctx.clearRect(40,60,100,60);
            //ctx.fillText("100ms passed",40,80);
            if (kosu == 5) {
                //ctx.fillText("jump to seikai.",40,80);
                seikai();
            }
        }, 200);
    }

    function seikai() {
            //ctx.fillText("yubi:",40,100);//
            //ctx.fillText(kosu,90,100);//
            //ctx.fillText(sikakus.length,90, 120);//
            //ctx.fillText(5-leftn,130, 120);//
            
            if (sikakus.length == 5-leftn){
                //ctx.fillText("jump to honto_seikai.", 40, 120);
                honto_seikai();
            } else {
                batu();
            }

    }

    function honto_seikai() {
        clearRect(100,140,200,180);
        ctx.fillStyle = 'red';
        ctx.fillText("◯", 100, 160);
        ctx.fillText(seikaisu_itirans[1][1], 120, 160);
        ctx.fillText("正解", 140, 160);
        // 正解音
        correct.play();
        // 正解数を増やす
        seikaisu_itirans[0][1] += 1;
        //
        if (seikaisu_itirans[0][1] >=seikaisu_itirans[0][2]) {
            // 大時計計時
            stage_clear_time = new Date().getTime - oodokei;
            seikaisu_itirans[0][3] = stage_clear_time;
            mode = 0;
            setTimeout(()=>{
                ctx.fillText("ステージクリア！", 40, 180);
                sentaku_aka(0);
            },3000);
        }
        setTimeout(() => {
            mode1();
        }, 800);
    }
    
    function batu() {
        //x1 = Math.floor(kleft+kwidth/2);
        //y1 = Math.floor(ktop+kheight/2);
        // Set the line style
        //ctx.strokeStyle = 'blue';
        //ctx.lineWidth = 10;
        //ctx.beginPath();
        //ctx.moveTo(kleft+100,ktop+100);
        //ctx.lineTo(kleft+300,ktop+300);
        //ctx.stroke();
        clearRect(100,140,200,180);
        ctx.fillStyle = 'blue';
        ctx.fillText("✕", 40, 160);//
        // 不正解音
        wrong.play();
        // 止める
        //stime = new Date().getTime;
        //while (new Date().getTime - stime < 5000) {
            // 何もしない
        //}
        return;
    }

    // 画面右の解答欄に四角を描く
    function sikaku_draw(sikakus){
        kaitouran_clear();
        sikakus.forEach(element => {
            x1 = element[0];
            y1 = element[1]; 
            ctx.fillStyle = 'skyblue'
            zx=-60;
            zy=-60;
            ctx.fillRect(x1+zx, y1+zy,50,50); 
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(x1+zx, y1+zy,50,50);
        });
    }

    // メニューを選択
    canvas.addEventListener("touchstart", function(e){ //<-touchstart
    if (mode == 0) {
        for (i=0;i<8;i++){
            if (100<e.pageX && e.pageX<100+300 && 100+50*i-30<e.pageY && e.pageY<100+50*i+10){
                mode = i+1;
            }
        } 
        if (mode==1){
            setTimeout(() => {
                mode1();
            }, 800);
        }
        //if (mode==2){mode2();}
    }
 
    // 同じcanvasを使っているので、すでにmode1の中ではこちらにくる。
    if (mode==1) {
    // 画面右のタッチ数を数える
        e.preventDefault();
        const touchPoints = e.touches;
        console.log(touchPoints);
        let yubicnt=0;
        sikakus = [];
        for (let i = 0; i < touchPoints.length; i++) {
            x1 = touchPoints[i].pageX;
            y1 = touchPoints[i].pageY;
            console.log("x1,y1=",x1,y1);
            if (kleft+50<x1 && x1<kleft+kwidth && 
                ktop+50<y1 && y1<ktop+kheight){
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        }
        sikaku_draw(sikakus);
        redraw_sikaku_plus(sikakus);

    }//if(move>0)
    },{passive: false});

    canvas.addEventListener("touchmove", function(e){
        e.preventDefault();
        const touchPoints = e.touches;
        let yubicnt=0;
        sikakus = [];
        for (let i = 0; i < touchPoints.length; i++) {
            x1 = touchPoints[i].pageX;
            y1 = touchPoints[i].pageY;
            if (kleft+50<x1 && x1<kleft+kwidth && 
                ktop+50<y1 && y1<ktop+kheight){
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        }
        sikaku_draw(sikakus);
        redraw_sikaku_plus(sikakus);
    
    },{passive: false});

    canvas.addEventListener("touchend", function(e) {
        e.preventDefault();
        // 残りのタッチポイントから消去対象を特定
        const touches = e.changedTouches;
        const remainingTouches = [];
        for (let i = 0; i < touchPoints.length; i++) {
            if (touches[0].identifier !== touchPoints[i].identifier) {
                remainingTouches.push(touchPoints[i]);
            }
        }       
        let yubicnt=0;
        sikakus = [];
        remainingTouches.forEach(element => {
            x1 = element.clientX
            y1 = element.clientY
            if (kleft+50<x1 && x1<kleft+kwidth && 
            ktop+50<y1 && y1<ktop+kheight){
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        });
        sikaku_draw(sikakus);
        redraw_sikaku_plus(sikakus);

    },{passive: false});


    // ----- main -----
        // メニューを表示
        sentaku_aka(0);


</script>    
</body>
</html>