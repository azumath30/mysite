<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOUCH event</title>
    <canvas id="canvas" width="1080" height="690"  ></canvas>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // 外枠の色と太さを設定
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    // 矩形を描画 (x, y, 幅, 高さ)
    ctx.strokeRect(0, 0, canvas.width-30, canvas.height-30);

    // 四角図形を描く
    let leftn;
    let kosu;
    let rectl = 160;
    let rectt = 270;
    let rectw = 50;
    // menu
    let r1 = 50;
    let mode;
    mode = -1;
    let yubikotae; // 指答え
    let yubicnt; // 指カウント
    // 解答欄
    let kleft = 550;
    let ktop = 50;
    let kwidth = 400;
    let kheight = 550;
    let isSeikai;
    isSeikai = false;
    let seikai_cnt;
    let touchPoints = [];
    let sikakus = [];
    let sikakus_ima = [];
    let sikakus_end = [];
    let stime;
    let stoptimes = [];
    let keikatime_h;
    let pushtime;
    // フォントの読み込み完了後に実行
    document.fonts.ready.then(() => {
    ctx.font = "20px 'sans-serif'";
    ctx.fillText("メニューv15", 70, 60);
    });
    document.fonts.ready.then(() => {
    ctx.font = "sans-serif 20px";
    ctx.fillText("１　５の分解",100,100);
    ctx.fillText('２　合わせて５になる足し算',100,100+r1);
    ctx.fillText('３　５以上になる足し算',100,100+r1*2);
    ctx.fillText('４　１０の分解',100,100+r1*3);
    ctx.fillText('５　繰り上がりなしの足し算１（足す数が５まで）',100,100+r1*4);
    ctx.fillText('６　１０いくつとの和',100,100+r1*5);
    ctx.fillText('７　２桁＋２桁（くりあがりなし）',100,100+r1*6);
    ctx.fillText('８　２桁＋２桁（くりあがりあり）',100,100+r1*7);
    });

    // ----- mode1 -----
    function mode1() {
        // canvas全体をクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 矩形を描画 (x, y, 幅, 高さ)
        ctx.strokeRect(0, 0, canvas.width-30, canvas.height-30);
        // タイトル
        ctx.font = "36px";
        ctx.fillText("５の分解",400,100);
        // 乱数の決定
        leftn = Math.floor(Math.random()*4)+1;
        console.log("leftn=",leftn);
        yubikotae = 5-leftn; 

        ctx.font = "96px";
        ctx.fillText("5  =",100,300);
        ctx.fillText("+",450,300);
        for (i=0;i<leftn;i++){
            // 四角塗りつぶし
            ctx.fillStyle = 'skyblue';
            ctx.fillRect(rectl+rectw*i, rectt, rectw, rectw);
            // 四角縁取り
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(rectl+rectw*i, rectt, rectw, rectw);
        }
        // 時計スタート
        stime = new Date();
        //ctx.font = "20px";
        //ctx.fillStyle = 'black';

        // 解答欄をクリア
        kaitouran_clear();
    }
    // 解答欄クリア
    function kaitouran_clear() {
        // 解答欄
        // 全体をクリア
        ctx.clearRect(kleft-20, ktop-20, kwidth+40, kheight+40);
        // 四角塗りつぶし
        // set transparency value
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = '#9bea33';
        ctx.fillRect(kleft, ktop, kwidth, kheight);

        // 四角縁取り
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(kleft, ktop, kwidth, kheight);
        ctx.globalAlpha = 1;
    }

    function redraw_sikaku_plus(sikakus) {
        ctx.clearRect(50,200,440,400);
        ctx.font = "96px";
        ctx.fillStyle = 'black';
        ctx.fillText("5  =",100,300);
        ctx.fillText("+",450,300);
        kosu = leftn + sikakus.length;
        ctx.clearRect(40,20,100,80);//
        ctx.fillText("kosu:",40,60)//
        ctx.fillText(kosu,90,60);//
        for (i=0;i<kosu;i++){
            // 四角塗りつぶし
            if (i<5) { //０始まりなので５
                ctx.fillStyle = 'skyblue';
            } 
            if (5<=i && i<10) {
                ctx.fillStyle = 'pink';
            } 
            xi = i % 5;
            yi = Math.floor(i/5);
            // 四角形
            ctx.fillRect(rectl+rectw*xi, rectt+(rectw+20)*yi, rectw, rectw);
            // 四角縁取り
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(rectl+rectw*xi, rectt+(rectw+20)*yi, rectw, rectw);
        }

        if (kosu == 5) {
            //isSeikai = true;
            ctx.fillText("jump to seikai.",40,80);
            seikai();
        }
    }

    function seikai() {
        //if (isSeikai == true) {
            ctx.fillText("kos2:",40,100)//
            ctx.fillText(kosu,90,100);//
            // 止める
            stime1 = new Date().getTime;
            while (new Date().getTime - stime1 < 1000) {
                // 何もしない
            }
            if (kosu == 5){
                ctx.filltext("jump to honto_seikai.",40, 120);
                honto_seikai();
            }
            ctx.fillText("kos2:",40,100)//
            
        //}
        //isSeikai = false;
    }

    function honto_seikai() {
        x1 = Math.floor(kleft+kwidth/2);
        y1 = Math.floor(ktop+kheight/2);
        ctx.fillStyle = 'red';
        ctx.arc(x1, y1, 100, 0, Math.PI * 2);
        // 止める
        stime = new Date().getTime;
        while (new Date().getTime - stime < 5000) {
            // 何もしない
        }
        mode = 91;

        isSeikai = false;
    }
    
    function batu() {
        //if (isSeikai == true) return
        x1 = Math.floor(kleft+kwidth/2);
        y1 = Math.floor(ktop+kheight/2);
        // Set the line style
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(kleft+100,ktop+100);
        ctx.lineTo(kleft+300,ktop+300);
        ctx.stroke();
        // 止める
        stime = new Date().getTime;
        while (new Date().getTime - stime < 5000) {
            // 何もしない
        }
        mode = 91;
        isSeikai = false;
        stoptimes = [];
        return;
    }

    function sikaku_draw(sikakus){
        kaitouran_clear();
        sikakus.forEach(element => {
            x1 = element[0];
            y1 = element[1]; 
            ctx.fillStyle = 'skyblue'
            zx=-60;
            zy=-60;
            ctx.fillRect(x1+zx, y1+zy,50,50); 
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(x1+zx, y1+zy,50,50);
        });
    }

    // メニューを選択
    canvas.addEventListener("touchstart", function(e){ //<-touchstart
    if (mode < 0) {
        ctx.fillText("2",10,10);
        yoko = 300;
        mode = 0;
        for (i=0;i<8;i++){
            if (100<e.pageX && e.pageX<100+300 && 100+50*i-30<e.pageY && e.pageY<100+50*i+10){
                mode = i+1;
                ctx.clearRect(200,10,20,20);
                st=String(mode)+":"+String(e.pageY);
                ctx.fillText(mode, 200, 60); //
            }
        } 
        if (mode==1){
            ctx.fillText(mode,20,20);
            mode1();
        }
    }

    if (mode==1) {
    // タッチ数を数える
        e.preventDefault();
        if (isSeikai == true) {return;}
        stoptimes.push(new Date() - stime);
        const touchPoints = e.touches;
        console.log(touchPoints);
        let yubicnt=0;
        sikakus = [];
        for (let i = 0; i < touchPoints.length; i++) {
            x1 = touchPoints[i].pageX;
            y1 = touchPoints[i].pageY;
            console.log("x1,y1=",x1,y1);
            if (kleft+50<x1 && x1<kleft+kwidth && 
                ktop+50<y1 && y1<ktop+kheight){
                if (mode==91){return} // 91は揃っているという意味
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        }
        sikaku_draw(sikakus);
        redraw_sikaku_plus(sikakus);
        // if (yubicnt==yubikotae && stoptimes.length==yubikotae) {
        //     isSeikai = true;
        //     seikai();
        // } 
        // if (new Date() - stime>5000){
        //     mode = 91;
        //     batu();
        // }
    }//if(move>0)
    },{passive: false});

    canvas.addEventListener("touchmove", function(e){
        e.preventDefault();
        if (isSeikai == true) {return;}
        const touchPoints = e.touches;
        let yubicnt=0;
        sikakus = [];
        for (let i = 0; i < touchPoints.length; i++) {
            x1 = touchPoints[i].pageX;
            y1 = touchPoints[i].pageY;
            if (kleft+50<x1 && x1<kleft+kwidth && 
                ktop+50<y1 && y1<ktop+kheight){
                if (mode==91){return} 
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        }
        sikaku_draw(sikakus);
        redraw_sikaku_plus(sikakus);
        // if (yubicnt==yubikotae && stoptimes.length==yubikotae) {
        //     isSeikai = true;
        //     seikai();
        // } else {
        //     batu();
        // }
    
    },{passive: false});

    canvas.addEventListener("touchend", function(e) {
        e.preventDefault();
        if (isSeikai == true) {return;}
        // 残りのタッチポイントから消去対象を特定
        const touches = e.changedTouches;
        const remainingTouches = [];
        for (let i = 0; i < touchPoints.length; i++) {
            if (touches[0].identifier !== touchPoints[i].identifier) {
                remainingTouches.push(touchPoints[i]);
            }
        }       
        let yubicnt=0;
        sikakus = [];
        remainingTouches.forEach(element => {
            x1 = element.clientX
            y1 = element.clientY
            if (kleft+50<x1 && x1<kleft+kwidth && 
            ktop+50<y1 && y1<ktop+kheight){
                if (mode==91){return} 
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        });
        sikaku_draw(sikakus);
        redraw_sikaku_plus(sikakus);
        // if (yubicnt==yubikotae && stoptimes.length==yubikotae) {
        //     isSeikai = true;
        //     seikai();
        // } else {
        //     batu();
        // }
    },{passive: false});


</script>    
</body>
</html>