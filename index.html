<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOUCH event</title>
    <canvas id="canvas" width="1080" height="690"  ></canvas>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // 外枠の色と太さを設定
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    // 矩形を描画 (x, y, 幅, 高さ)
    ctx.strokeRect(0, 0, canvas.width-30, canvas.height-30);

    // menu
    let r1 = 50;
    let mode;
    let yubikotae;
    // 解答欄
    let kleft = 550;
    let ktop = 50;
    let kwidth = 400;
    let kheight = 550;
    let isSeikai;
    isSeikai = false;
    let touchPoints = [];
    let sikakus = [];
    let sikakus_ima = [];
    let sikakus_end = [];
    let stime;
    let keikatime;
    let pushtime;
    // フォントの読み込み完了後に実行
    document.fonts.ready.then(() => {
    ctx.font = "20px 'sans-serif'";
    ctx.fillText("メニューv12", 70, 60);
    });
    document.fonts.ready.then(() => {
    ctx.font = "sans-serif 20px";
    ctx.fillText("１　５の分解",100,100);
    ctx.fillText('２　合わせて５になる足し算',100,100+r1);
    ctx.fillText('３　５以上になる足し算',100,100+r1*2);
    ctx.fillText('４　１０の分解',100,100+r1*3);
    ctx.fillText('５　繰り上がりなしの足し算１（足す数が５まで）',100,100+r1*4);
    ctx.fillText('６　１０いくつとの和',100,100+r1*5);
    ctx.fillText('７　２桁＋２桁（くりあがりなし）',100,100+r1*6);
    ctx.fillText('８　２桁＋２桁（くりあがりあり）',100,100+r1*7);
    });

    // ----- mode1 -----
    function mode1() {
        // canvas全体をクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 矩形を描画 (x, y, 幅, 高さ)
        ctx.strokeRect(0, 0, canvas.width-30, canvas.height-30);
        // タイトル
        ctx.font = "36px";
        ctx.fillText("５の分解",400,100);
        // 
        leftn = Math.floor(Math.random()*4)+1;
        yubikotae = 5-leftn; 
        //
        let rectl = 160;
        let rectt = 270;
        let rectw = 50;
        ctx.font = "96px";
        ctx.fillText("5  =",100,300);
        ctx.fillText("+",450,300);
        for (i=0;i<leftn;i++){
            // 四角塗りつぶし
            ctx.fillStyle = 'skyblue';
            ctx.fillRect(rectl+rectw*i, rectt, rectw, rectw);
            // 四角縁取り
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(rectl+rectw*i, rectt, rectw, rectw);
        }
        
        kaitouran_clear();
        // 時計スタート
        stime = new Date();
        timehyouji();
    }

    function timehyouji() {
        if (keikatime_h>10) {return}
        timeid = setTimeout(() => {
            keikatime = new Date() - stime;
            keikatime_h = Math.floor(keikatime/1000).toFixed(1);
            ctx.fillStyle = 'black';
            ctx.fillText(keikatime_h, 400, 150)
            timehyouji(); 
        }, 100);
    }

    function kaitouran_clear() {
        // 解答欄
        // 全体をクリア
        ctx.clearRect(kleft-20, ktop-20, kwidth+40, kheight+40);
        // 四角塗りつぶし
        // set transparency value
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = '#9bea33';
        ctx.fillRect(kleft, ktop, kwidth, kheight);

        // 四角縁取り
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(kleft, ktop, kwidth, kheight);

    }

    function seikai() {
        if (isSeikai == true) return
        x1 = Math.floor(kleft+kwidth/2);
        y1 = Math.floor(ktop+kheight/2);
        ctx.fillStyle = 'red';
        ctx.arc(x1, y1, 100, 0, Math.PI * 2);
        ctx.fill();
        mode = 91;
        clearTimeout(timeid);
        isSeikai = false;
    }
    
    function batu() {
        return;
    }

    function sikaku_drwaw(sikakus){
        kaitouran_clear();
        sikakus.forEach(element => {
            x1 = element[0];
            y1 = element[1]; 
            ctx.fillStyle = 'skyblue'
            zx=-60;
            zy=-60;
            ctx.fillRect(x1+zx, y1+zy,50,50); 
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(x1+zx, y1+zy,50,50);
        });
    }

    // メニューを選択
    canvas.addEventListener("touchstart", function(e){ //<-touchstart
        if (mode>0) {return}
        //
        ctx.fillText("2",10,10);
        yoko = 300;
        mode = 0;
        for (i=0;i<8;i++){
            if (100<e.pageX && e.pageX<100+300 && 100+50*i-30<e.pageY && e.pageY<100+50*i+10){
                mode = i+1;
                ctx.clearRect(200,10,20,20);
                st=String(mode)+":"+String(e.pageY);
                ctx.fillText(mode, 200, 60); //
            }
        } 
        if (mode==1){
            ctx.fillText(mode,20,20);
            mode1();
        }
    },{passive: false});

    // タッチ数を数える
    canvas.addEventListener("touchstart", function(e){
        e.preventDefault();
        if (isSeikai == true) {return;}
        const touchPoints = e.touches;
        let yubicnt=0;
        sikakus = [];
        for (let i = 0; i < touchPoints.length; i++) {
            x1 = touchPoints[i].pageX;
            y1 = touchPoints[i].pageY;
            if (kleft+50<x1 && x1<kleft+kwidth && 
                ktop+50<y1 && y1<ktop+kheight){
                if (mode==91){return} 
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        }
        sikaku_drwaw(sikakus);
        if (yubicnt==yubikotae) {
            isSeikai = true;
            seikai();
        } else {
            batu();
        }
    },{passive: false});
    canvas.addEventListener("touchmove", function(e){
        e.preventDefault();
        if (isSeikai == true) {return;}
        const touchPoints = e.touches;
        let yubicnt=0;
        sikakus = [];
        for (let i = 0; i < touchPoints.length; i++) {
            x1 = touchPoints[i].pageX;
            y1 = touchPoints[i].pageY;
            if (kleft+50<x1 && x1<kleft+kwidth && 
                ktop+50<y1 && y1<ktop+kheight){
                if (mode==91){return} 
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        }
        sikaku_drwaw(sikakus);
        if (yubicnt==yubikotae) {
            isSeikai = true;
            seikai();
        } else {
            batu();
        }
    },{passive: false});
    canvas.addEventListener("touchend", function(e) {
        e.preventDefault();
        if (isSeikai == true) {return;}
        // 残りのタッチポイントから消去対象を特定
        const touches = e.changedTouches;
        const remainingTouches = [];
        for (let i = 0; i < touchPoints.length; i++) {
            if (touches[0].identifier !== touchPoints[i].identifier) {
                remainingTouches.push(touchPoints[i]);
            }
        }       
        let yubicnt=0;
        sikakus = [];
        remainingTouches.forEach(element => {
            x1 = element.clientX
            y1 = element.clientY
            if (kleft+50<x1 && x1<kleft+kwidth && 
            ktop+50<y1 && y1<ktop+kheight){
                if (mode==91){return} 
                yubicnt += 1;
                sikakus.push([x1,y1]);
            }
        });
        sikaku_drwaw(sikakus);
        if (yubicnt==yubikotae) {
            isSeikai = true;
            seikai();
        } else {
            batu();
        }
    },{passive: false});


</script>    
</body>
</html>